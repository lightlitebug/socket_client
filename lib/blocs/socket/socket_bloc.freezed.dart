// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'socket_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$SocketEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() connect,
    required TResult Function() connecting,
    required TResult Function() onConnect,
    required TResult Function() onConnectError,
    required TResult Function() onConnectTimeout,
    required TResult Function() onError,
    required TResult Function() onJoined,
    required TResult Function() disconnect,
    required TResult Function() onDisconnect,
    required TResult Function() sendMessage,
    required TResult Function(String message) receiveMessage,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? connect,
    TResult? Function()? connecting,
    TResult? Function()? onConnect,
    TResult? Function()? onConnectError,
    TResult? Function()? onConnectTimeout,
    TResult? Function()? onError,
    TResult? Function()? onJoined,
    TResult? Function()? disconnect,
    TResult? Function()? onDisconnect,
    TResult? Function()? sendMessage,
    TResult? Function(String message)? receiveMessage,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? connect,
    TResult Function()? connecting,
    TResult Function()? onConnect,
    TResult Function()? onConnectError,
    TResult Function()? onConnectTimeout,
    TResult Function()? onError,
    TResult Function()? onJoined,
    TResult Function()? disconnect,
    TResult Function()? onDisconnect,
    TResult Function()? sendMessage,
    TResult Function(String message)? receiveMessage,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SocketConnect value) connect,
    required TResult Function(_SocketConnectingEvent value) connecting,
    required TResult Function(_SocketOnConnect value) onConnect,
    required TResult Function(_SocketConnectErrorEvent value) onConnectError,
    required TResult Function(_SocketConnectTimeoutEvent value)
        onConnectTimeout,
    required TResult Function(_SocketErrorEvent value) onError,
    required TResult Function(_SocketJoinedEvent value) onJoined,
    required TResult Function(_SocketDisconnect value) disconnect,
    required TResult Function(_SocketOnDisconnect value) onDisconnect,
    required TResult Function(_SocketSendMessage value) sendMessage,
    required TResult Function(_SocketReceiveMessage value) receiveMessage,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SocketConnect value)? connect,
    TResult? Function(_SocketConnectingEvent value)? connecting,
    TResult? Function(_SocketOnConnect value)? onConnect,
    TResult? Function(_SocketConnectErrorEvent value)? onConnectError,
    TResult? Function(_SocketConnectTimeoutEvent value)? onConnectTimeout,
    TResult? Function(_SocketErrorEvent value)? onError,
    TResult? Function(_SocketJoinedEvent value)? onJoined,
    TResult? Function(_SocketDisconnect value)? disconnect,
    TResult? Function(_SocketOnDisconnect value)? onDisconnect,
    TResult? Function(_SocketSendMessage value)? sendMessage,
    TResult? Function(_SocketReceiveMessage value)? receiveMessage,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SocketConnect value)? connect,
    TResult Function(_SocketConnectingEvent value)? connecting,
    TResult Function(_SocketOnConnect value)? onConnect,
    TResult Function(_SocketConnectErrorEvent value)? onConnectError,
    TResult Function(_SocketConnectTimeoutEvent value)? onConnectTimeout,
    TResult Function(_SocketErrorEvent value)? onError,
    TResult Function(_SocketJoinedEvent value)? onJoined,
    TResult Function(_SocketDisconnect value)? disconnect,
    TResult Function(_SocketOnDisconnect value)? onDisconnect,
    TResult Function(_SocketSendMessage value)? sendMessage,
    TResult Function(_SocketReceiveMessage value)? receiveMessage,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SocketEventCopyWith<$Res> {
  factory $SocketEventCopyWith(
          SocketEvent value, $Res Function(SocketEvent) then) =
      _$SocketEventCopyWithImpl<$Res, SocketEvent>;
}

/// @nodoc
class _$SocketEventCopyWithImpl<$Res, $Val extends SocketEvent>
    implements $SocketEventCopyWith<$Res> {
  _$SocketEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_SocketConnectCopyWith<$Res> {
  factory _$$_SocketConnectCopyWith(
          _$_SocketConnect value, $Res Function(_$_SocketConnect) then) =
      __$$_SocketConnectCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_SocketConnectCopyWithImpl<$Res>
    extends _$SocketEventCopyWithImpl<$Res, _$_SocketConnect>
    implements _$$_SocketConnectCopyWith<$Res> {
  __$$_SocketConnectCopyWithImpl(
      _$_SocketConnect _value, $Res Function(_$_SocketConnect) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_SocketConnect implements _SocketConnect {
  const _$_SocketConnect();

  @override
  String toString() {
    return 'SocketEvent.connect()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_SocketConnect);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() connect,
    required TResult Function() connecting,
    required TResult Function() onConnect,
    required TResult Function() onConnectError,
    required TResult Function() onConnectTimeout,
    required TResult Function() onError,
    required TResult Function() onJoined,
    required TResult Function() disconnect,
    required TResult Function() onDisconnect,
    required TResult Function() sendMessage,
    required TResult Function(String message) receiveMessage,
  }) {
    return connect();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? connect,
    TResult? Function()? connecting,
    TResult? Function()? onConnect,
    TResult? Function()? onConnectError,
    TResult? Function()? onConnectTimeout,
    TResult? Function()? onError,
    TResult? Function()? onJoined,
    TResult? Function()? disconnect,
    TResult? Function()? onDisconnect,
    TResult? Function()? sendMessage,
    TResult? Function(String message)? receiveMessage,
  }) {
    return connect?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? connect,
    TResult Function()? connecting,
    TResult Function()? onConnect,
    TResult Function()? onConnectError,
    TResult Function()? onConnectTimeout,
    TResult Function()? onError,
    TResult Function()? onJoined,
    TResult Function()? disconnect,
    TResult Function()? onDisconnect,
    TResult Function()? sendMessage,
    TResult Function(String message)? receiveMessage,
    required TResult orElse(),
  }) {
    if (connect != null) {
      return connect();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SocketConnect value) connect,
    required TResult Function(_SocketConnectingEvent value) connecting,
    required TResult Function(_SocketOnConnect value) onConnect,
    required TResult Function(_SocketConnectErrorEvent value) onConnectError,
    required TResult Function(_SocketConnectTimeoutEvent value)
        onConnectTimeout,
    required TResult Function(_SocketErrorEvent value) onError,
    required TResult Function(_SocketJoinedEvent value) onJoined,
    required TResult Function(_SocketDisconnect value) disconnect,
    required TResult Function(_SocketOnDisconnect value) onDisconnect,
    required TResult Function(_SocketSendMessage value) sendMessage,
    required TResult Function(_SocketReceiveMessage value) receiveMessage,
  }) {
    return connect(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SocketConnect value)? connect,
    TResult? Function(_SocketConnectingEvent value)? connecting,
    TResult? Function(_SocketOnConnect value)? onConnect,
    TResult? Function(_SocketConnectErrorEvent value)? onConnectError,
    TResult? Function(_SocketConnectTimeoutEvent value)? onConnectTimeout,
    TResult? Function(_SocketErrorEvent value)? onError,
    TResult? Function(_SocketJoinedEvent value)? onJoined,
    TResult? Function(_SocketDisconnect value)? disconnect,
    TResult? Function(_SocketOnDisconnect value)? onDisconnect,
    TResult? Function(_SocketSendMessage value)? sendMessage,
    TResult? Function(_SocketReceiveMessage value)? receiveMessage,
  }) {
    return connect?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SocketConnect value)? connect,
    TResult Function(_SocketConnectingEvent value)? connecting,
    TResult Function(_SocketOnConnect value)? onConnect,
    TResult Function(_SocketConnectErrorEvent value)? onConnectError,
    TResult Function(_SocketConnectTimeoutEvent value)? onConnectTimeout,
    TResult Function(_SocketErrorEvent value)? onError,
    TResult Function(_SocketJoinedEvent value)? onJoined,
    TResult Function(_SocketDisconnect value)? disconnect,
    TResult Function(_SocketOnDisconnect value)? onDisconnect,
    TResult Function(_SocketSendMessage value)? sendMessage,
    TResult Function(_SocketReceiveMessage value)? receiveMessage,
    required TResult orElse(),
  }) {
    if (connect != null) {
      return connect(this);
    }
    return orElse();
  }
}

abstract class _SocketConnect implements SocketEvent {
  const factory _SocketConnect() = _$_SocketConnect;
}

/// @nodoc
abstract class _$$_SocketConnectingEventCopyWith<$Res> {
  factory _$$_SocketConnectingEventCopyWith(_$_SocketConnectingEvent value,
          $Res Function(_$_SocketConnectingEvent) then) =
      __$$_SocketConnectingEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_SocketConnectingEventCopyWithImpl<$Res>
    extends _$SocketEventCopyWithImpl<$Res, _$_SocketConnectingEvent>
    implements _$$_SocketConnectingEventCopyWith<$Res> {
  __$$_SocketConnectingEventCopyWithImpl(_$_SocketConnectingEvent _value,
      $Res Function(_$_SocketConnectingEvent) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_SocketConnectingEvent implements _SocketConnectingEvent {
  const _$_SocketConnectingEvent();

  @override
  String toString() {
    return 'SocketEvent.connecting()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_SocketConnectingEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() connect,
    required TResult Function() connecting,
    required TResult Function() onConnect,
    required TResult Function() onConnectError,
    required TResult Function() onConnectTimeout,
    required TResult Function() onError,
    required TResult Function() onJoined,
    required TResult Function() disconnect,
    required TResult Function() onDisconnect,
    required TResult Function() sendMessage,
    required TResult Function(String message) receiveMessage,
  }) {
    return connecting();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? connect,
    TResult? Function()? connecting,
    TResult? Function()? onConnect,
    TResult? Function()? onConnectError,
    TResult? Function()? onConnectTimeout,
    TResult? Function()? onError,
    TResult? Function()? onJoined,
    TResult? Function()? disconnect,
    TResult? Function()? onDisconnect,
    TResult? Function()? sendMessage,
    TResult? Function(String message)? receiveMessage,
  }) {
    return connecting?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? connect,
    TResult Function()? connecting,
    TResult Function()? onConnect,
    TResult Function()? onConnectError,
    TResult Function()? onConnectTimeout,
    TResult Function()? onError,
    TResult Function()? onJoined,
    TResult Function()? disconnect,
    TResult Function()? onDisconnect,
    TResult Function()? sendMessage,
    TResult Function(String message)? receiveMessage,
    required TResult orElse(),
  }) {
    if (connecting != null) {
      return connecting();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SocketConnect value) connect,
    required TResult Function(_SocketConnectingEvent value) connecting,
    required TResult Function(_SocketOnConnect value) onConnect,
    required TResult Function(_SocketConnectErrorEvent value) onConnectError,
    required TResult Function(_SocketConnectTimeoutEvent value)
        onConnectTimeout,
    required TResult Function(_SocketErrorEvent value) onError,
    required TResult Function(_SocketJoinedEvent value) onJoined,
    required TResult Function(_SocketDisconnect value) disconnect,
    required TResult Function(_SocketOnDisconnect value) onDisconnect,
    required TResult Function(_SocketSendMessage value) sendMessage,
    required TResult Function(_SocketReceiveMessage value) receiveMessage,
  }) {
    return connecting(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SocketConnect value)? connect,
    TResult? Function(_SocketConnectingEvent value)? connecting,
    TResult? Function(_SocketOnConnect value)? onConnect,
    TResult? Function(_SocketConnectErrorEvent value)? onConnectError,
    TResult? Function(_SocketConnectTimeoutEvent value)? onConnectTimeout,
    TResult? Function(_SocketErrorEvent value)? onError,
    TResult? Function(_SocketJoinedEvent value)? onJoined,
    TResult? Function(_SocketDisconnect value)? disconnect,
    TResult? Function(_SocketOnDisconnect value)? onDisconnect,
    TResult? Function(_SocketSendMessage value)? sendMessage,
    TResult? Function(_SocketReceiveMessage value)? receiveMessage,
  }) {
    return connecting?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SocketConnect value)? connect,
    TResult Function(_SocketConnectingEvent value)? connecting,
    TResult Function(_SocketOnConnect value)? onConnect,
    TResult Function(_SocketConnectErrorEvent value)? onConnectError,
    TResult Function(_SocketConnectTimeoutEvent value)? onConnectTimeout,
    TResult Function(_SocketErrorEvent value)? onError,
    TResult Function(_SocketJoinedEvent value)? onJoined,
    TResult Function(_SocketDisconnect value)? disconnect,
    TResult Function(_SocketOnDisconnect value)? onDisconnect,
    TResult Function(_SocketSendMessage value)? sendMessage,
    TResult Function(_SocketReceiveMessage value)? receiveMessage,
    required TResult orElse(),
  }) {
    if (connecting != null) {
      return connecting(this);
    }
    return orElse();
  }
}

abstract class _SocketConnectingEvent implements SocketEvent {
  const factory _SocketConnectingEvent() = _$_SocketConnectingEvent;
}

/// @nodoc
abstract class _$$_SocketOnConnectCopyWith<$Res> {
  factory _$$_SocketOnConnectCopyWith(
          _$_SocketOnConnect value, $Res Function(_$_SocketOnConnect) then) =
      __$$_SocketOnConnectCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_SocketOnConnectCopyWithImpl<$Res>
    extends _$SocketEventCopyWithImpl<$Res, _$_SocketOnConnect>
    implements _$$_SocketOnConnectCopyWith<$Res> {
  __$$_SocketOnConnectCopyWithImpl(
      _$_SocketOnConnect _value, $Res Function(_$_SocketOnConnect) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_SocketOnConnect implements _SocketOnConnect {
  const _$_SocketOnConnect();

  @override
  String toString() {
    return 'SocketEvent.onConnect()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_SocketOnConnect);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() connect,
    required TResult Function() connecting,
    required TResult Function() onConnect,
    required TResult Function() onConnectError,
    required TResult Function() onConnectTimeout,
    required TResult Function() onError,
    required TResult Function() onJoined,
    required TResult Function() disconnect,
    required TResult Function() onDisconnect,
    required TResult Function() sendMessage,
    required TResult Function(String message) receiveMessage,
  }) {
    return onConnect();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? connect,
    TResult? Function()? connecting,
    TResult? Function()? onConnect,
    TResult? Function()? onConnectError,
    TResult? Function()? onConnectTimeout,
    TResult? Function()? onError,
    TResult? Function()? onJoined,
    TResult? Function()? disconnect,
    TResult? Function()? onDisconnect,
    TResult? Function()? sendMessage,
    TResult? Function(String message)? receiveMessage,
  }) {
    return onConnect?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? connect,
    TResult Function()? connecting,
    TResult Function()? onConnect,
    TResult Function()? onConnectError,
    TResult Function()? onConnectTimeout,
    TResult Function()? onError,
    TResult Function()? onJoined,
    TResult Function()? disconnect,
    TResult Function()? onDisconnect,
    TResult Function()? sendMessage,
    TResult Function(String message)? receiveMessage,
    required TResult orElse(),
  }) {
    if (onConnect != null) {
      return onConnect();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SocketConnect value) connect,
    required TResult Function(_SocketConnectingEvent value) connecting,
    required TResult Function(_SocketOnConnect value) onConnect,
    required TResult Function(_SocketConnectErrorEvent value) onConnectError,
    required TResult Function(_SocketConnectTimeoutEvent value)
        onConnectTimeout,
    required TResult Function(_SocketErrorEvent value) onError,
    required TResult Function(_SocketJoinedEvent value) onJoined,
    required TResult Function(_SocketDisconnect value) disconnect,
    required TResult Function(_SocketOnDisconnect value) onDisconnect,
    required TResult Function(_SocketSendMessage value) sendMessage,
    required TResult Function(_SocketReceiveMessage value) receiveMessage,
  }) {
    return onConnect(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SocketConnect value)? connect,
    TResult? Function(_SocketConnectingEvent value)? connecting,
    TResult? Function(_SocketOnConnect value)? onConnect,
    TResult? Function(_SocketConnectErrorEvent value)? onConnectError,
    TResult? Function(_SocketConnectTimeoutEvent value)? onConnectTimeout,
    TResult? Function(_SocketErrorEvent value)? onError,
    TResult? Function(_SocketJoinedEvent value)? onJoined,
    TResult? Function(_SocketDisconnect value)? disconnect,
    TResult? Function(_SocketOnDisconnect value)? onDisconnect,
    TResult? Function(_SocketSendMessage value)? sendMessage,
    TResult? Function(_SocketReceiveMessage value)? receiveMessage,
  }) {
    return onConnect?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SocketConnect value)? connect,
    TResult Function(_SocketConnectingEvent value)? connecting,
    TResult Function(_SocketOnConnect value)? onConnect,
    TResult Function(_SocketConnectErrorEvent value)? onConnectError,
    TResult Function(_SocketConnectTimeoutEvent value)? onConnectTimeout,
    TResult Function(_SocketErrorEvent value)? onError,
    TResult Function(_SocketJoinedEvent value)? onJoined,
    TResult Function(_SocketDisconnect value)? disconnect,
    TResult Function(_SocketOnDisconnect value)? onDisconnect,
    TResult Function(_SocketSendMessage value)? sendMessage,
    TResult Function(_SocketReceiveMessage value)? receiveMessage,
    required TResult orElse(),
  }) {
    if (onConnect != null) {
      return onConnect(this);
    }
    return orElse();
  }
}

abstract class _SocketOnConnect implements SocketEvent {
  const factory _SocketOnConnect() = _$_SocketOnConnect;
}

/// @nodoc
abstract class _$$_SocketConnectErrorEventCopyWith<$Res> {
  factory _$$_SocketConnectErrorEventCopyWith(_$_SocketConnectErrorEvent value,
          $Res Function(_$_SocketConnectErrorEvent) then) =
      __$$_SocketConnectErrorEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_SocketConnectErrorEventCopyWithImpl<$Res>
    extends _$SocketEventCopyWithImpl<$Res, _$_SocketConnectErrorEvent>
    implements _$$_SocketConnectErrorEventCopyWith<$Res> {
  __$$_SocketConnectErrorEventCopyWithImpl(_$_SocketConnectErrorEvent _value,
      $Res Function(_$_SocketConnectErrorEvent) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_SocketConnectErrorEvent implements _SocketConnectErrorEvent {
  const _$_SocketConnectErrorEvent();

  @override
  String toString() {
    return 'SocketEvent.onConnectError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SocketConnectErrorEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() connect,
    required TResult Function() connecting,
    required TResult Function() onConnect,
    required TResult Function() onConnectError,
    required TResult Function() onConnectTimeout,
    required TResult Function() onError,
    required TResult Function() onJoined,
    required TResult Function() disconnect,
    required TResult Function() onDisconnect,
    required TResult Function() sendMessage,
    required TResult Function(String message) receiveMessage,
  }) {
    return onConnectError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? connect,
    TResult? Function()? connecting,
    TResult? Function()? onConnect,
    TResult? Function()? onConnectError,
    TResult? Function()? onConnectTimeout,
    TResult? Function()? onError,
    TResult? Function()? onJoined,
    TResult? Function()? disconnect,
    TResult? Function()? onDisconnect,
    TResult? Function()? sendMessage,
    TResult? Function(String message)? receiveMessage,
  }) {
    return onConnectError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? connect,
    TResult Function()? connecting,
    TResult Function()? onConnect,
    TResult Function()? onConnectError,
    TResult Function()? onConnectTimeout,
    TResult Function()? onError,
    TResult Function()? onJoined,
    TResult Function()? disconnect,
    TResult Function()? onDisconnect,
    TResult Function()? sendMessage,
    TResult Function(String message)? receiveMessage,
    required TResult orElse(),
  }) {
    if (onConnectError != null) {
      return onConnectError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SocketConnect value) connect,
    required TResult Function(_SocketConnectingEvent value) connecting,
    required TResult Function(_SocketOnConnect value) onConnect,
    required TResult Function(_SocketConnectErrorEvent value) onConnectError,
    required TResult Function(_SocketConnectTimeoutEvent value)
        onConnectTimeout,
    required TResult Function(_SocketErrorEvent value) onError,
    required TResult Function(_SocketJoinedEvent value) onJoined,
    required TResult Function(_SocketDisconnect value) disconnect,
    required TResult Function(_SocketOnDisconnect value) onDisconnect,
    required TResult Function(_SocketSendMessage value) sendMessage,
    required TResult Function(_SocketReceiveMessage value) receiveMessage,
  }) {
    return onConnectError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SocketConnect value)? connect,
    TResult? Function(_SocketConnectingEvent value)? connecting,
    TResult? Function(_SocketOnConnect value)? onConnect,
    TResult? Function(_SocketConnectErrorEvent value)? onConnectError,
    TResult? Function(_SocketConnectTimeoutEvent value)? onConnectTimeout,
    TResult? Function(_SocketErrorEvent value)? onError,
    TResult? Function(_SocketJoinedEvent value)? onJoined,
    TResult? Function(_SocketDisconnect value)? disconnect,
    TResult? Function(_SocketOnDisconnect value)? onDisconnect,
    TResult? Function(_SocketSendMessage value)? sendMessage,
    TResult? Function(_SocketReceiveMessage value)? receiveMessage,
  }) {
    return onConnectError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SocketConnect value)? connect,
    TResult Function(_SocketConnectingEvent value)? connecting,
    TResult Function(_SocketOnConnect value)? onConnect,
    TResult Function(_SocketConnectErrorEvent value)? onConnectError,
    TResult Function(_SocketConnectTimeoutEvent value)? onConnectTimeout,
    TResult Function(_SocketErrorEvent value)? onError,
    TResult Function(_SocketJoinedEvent value)? onJoined,
    TResult Function(_SocketDisconnect value)? disconnect,
    TResult Function(_SocketOnDisconnect value)? onDisconnect,
    TResult Function(_SocketSendMessage value)? sendMessage,
    TResult Function(_SocketReceiveMessage value)? receiveMessage,
    required TResult orElse(),
  }) {
    if (onConnectError != null) {
      return onConnectError(this);
    }
    return orElse();
  }
}

abstract class _SocketConnectErrorEvent implements SocketEvent {
  const factory _SocketConnectErrorEvent() = _$_SocketConnectErrorEvent;
}

/// @nodoc
abstract class _$$_SocketConnectTimeoutEventCopyWith<$Res> {
  factory _$$_SocketConnectTimeoutEventCopyWith(
          _$_SocketConnectTimeoutEvent value,
          $Res Function(_$_SocketConnectTimeoutEvent) then) =
      __$$_SocketConnectTimeoutEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_SocketConnectTimeoutEventCopyWithImpl<$Res>
    extends _$SocketEventCopyWithImpl<$Res, _$_SocketConnectTimeoutEvent>
    implements _$$_SocketConnectTimeoutEventCopyWith<$Res> {
  __$$_SocketConnectTimeoutEventCopyWithImpl(
      _$_SocketConnectTimeoutEvent _value,
      $Res Function(_$_SocketConnectTimeoutEvent) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_SocketConnectTimeoutEvent implements _SocketConnectTimeoutEvent {
  const _$_SocketConnectTimeoutEvent();

  @override
  String toString() {
    return 'SocketEvent.onConnectTimeout()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SocketConnectTimeoutEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() connect,
    required TResult Function() connecting,
    required TResult Function() onConnect,
    required TResult Function() onConnectError,
    required TResult Function() onConnectTimeout,
    required TResult Function() onError,
    required TResult Function() onJoined,
    required TResult Function() disconnect,
    required TResult Function() onDisconnect,
    required TResult Function() sendMessage,
    required TResult Function(String message) receiveMessage,
  }) {
    return onConnectTimeout();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? connect,
    TResult? Function()? connecting,
    TResult? Function()? onConnect,
    TResult? Function()? onConnectError,
    TResult? Function()? onConnectTimeout,
    TResult? Function()? onError,
    TResult? Function()? onJoined,
    TResult? Function()? disconnect,
    TResult? Function()? onDisconnect,
    TResult? Function()? sendMessage,
    TResult? Function(String message)? receiveMessage,
  }) {
    return onConnectTimeout?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? connect,
    TResult Function()? connecting,
    TResult Function()? onConnect,
    TResult Function()? onConnectError,
    TResult Function()? onConnectTimeout,
    TResult Function()? onError,
    TResult Function()? onJoined,
    TResult Function()? disconnect,
    TResult Function()? onDisconnect,
    TResult Function()? sendMessage,
    TResult Function(String message)? receiveMessage,
    required TResult orElse(),
  }) {
    if (onConnectTimeout != null) {
      return onConnectTimeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SocketConnect value) connect,
    required TResult Function(_SocketConnectingEvent value) connecting,
    required TResult Function(_SocketOnConnect value) onConnect,
    required TResult Function(_SocketConnectErrorEvent value) onConnectError,
    required TResult Function(_SocketConnectTimeoutEvent value)
        onConnectTimeout,
    required TResult Function(_SocketErrorEvent value) onError,
    required TResult Function(_SocketJoinedEvent value) onJoined,
    required TResult Function(_SocketDisconnect value) disconnect,
    required TResult Function(_SocketOnDisconnect value) onDisconnect,
    required TResult Function(_SocketSendMessage value) sendMessage,
    required TResult Function(_SocketReceiveMessage value) receiveMessage,
  }) {
    return onConnectTimeout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SocketConnect value)? connect,
    TResult? Function(_SocketConnectingEvent value)? connecting,
    TResult? Function(_SocketOnConnect value)? onConnect,
    TResult? Function(_SocketConnectErrorEvent value)? onConnectError,
    TResult? Function(_SocketConnectTimeoutEvent value)? onConnectTimeout,
    TResult? Function(_SocketErrorEvent value)? onError,
    TResult? Function(_SocketJoinedEvent value)? onJoined,
    TResult? Function(_SocketDisconnect value)? disconnect,
    TResult? Function(_SocketOnDisconnect value)? onDisconnect,
    TResult? Function(_SocketSendMessage value)? sendMessage,
    TResult? Function(_SocketReceiveMessage value)? receiveMessage,
  }) {
    return onConnectTimeout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SocketConnect value)? connect,
    TResult Function(_SocketConnectingEvent value)? connecting,
    TResult Function(_SocketOnConnect value)? onConnect,
    TResult Function(_SocketConnectErrorEvent value)? onConnectError,
    TResult Function(_SocketConnectTimeoutEvent value)? onConnectTimeout,
    TResult Function(_SocketErrorEvent value)? onError,
    TResult Function(_SocketJoinedEvent value)? onJoined,
    TResult Function(_SocketDisconnect value)? disconnect,
    TResult Function(_SocketOnDisconnect value)? onDisconnect,
    TResult Function(_SocketSendMessage value)? sendMessage,
    TResult Function(_SocketReceiveMessage value)? receiveMessage,
    required TResult orElse(),
  }) {
    if (onConnectTimeout != null) {
      return onConnectTimeout(this);
    }
    return orElse();
  }
}

abstract class _SocketConnectTimeoutEvent implements SocketEvent {
  const factory _SocketConnectTimeoutEvent() = _$_SocketConnectTimeoutEvent;
}

/// @nodoc
abstract class _$$_SocketErrorEventCopyWith<$Res> {
  factory _$$_SocketErrorEventCopyWith(
          _$_SocketErrorEvent value, $Res Function(_$_SocketErrorEvent) then) =
      __$$_SocketErrorEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_SocketErrorEventCopyWithImpl<$Res>
    extends _$SocketEventCopyWithImpl<$Res, _$_SocketErrorEvent>
    implements _$$_SocketErrorEventCopyWith<$Res> {
  __$$_SocketErrorEventCopyWithImpl(
      _$_SocketErrorEvent _value, $Res Function(_$_SocketErrorEvent) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_SocketErrorEvent implements _SocketErrorEvent {
  const _$_SocketErrorEvent();

  @override
  String toString() {
    return 'SocketEvent.onError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_SocketErrorEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() connect,
    required TResult Function() connecting,
    required TResult Function() onConnect,
    required TResult Function() onConnectError,
    required TResult Function() onConnectTimeout,
    required TResult Function() onError,
    required TResult Function() onJoined,
    required TResult Function() disconnect,
    required TResult Function() onDisconnect,
    required TResult Function() sendMessage,
    required TResult Function(String message) receiveMessage,
  }) {
    return onError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? connect,
    TResult? Function()? connecting,
    TResult? Function()? onConnect,
    TResult? Function()? onConnectError,
    TResult? Function()? onConnectTimeout,
    TResult? Function()? onError,
    TResult? Function()? onJoined,
    TResult? Function()? disconnect,
    TResult? Function()? onDisconnect,
    TResult? Function()? sendMessage,
    TResult? Function(String message)? receiveMessage,
  }) {
    return onError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? connect,
    TResult Function()? connecting,
    TResult Function()? onConnect,
    TResult Function()? onConnectError,
    TResult Function()? onConnectTimeout,
    TResult Function()? onError,
    TResult Function()? onJoined,
    TResult Function()? disconnect,
    TResult Function()? onDisconnect,
    TResult Function()? sendMessage,
    TResult Function(String message)? receiveMessage,
    required TResult orElse(),
  }) {
    if (onError != null) {
      return onError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SocketConnect value) connect,
    required TResult Function(_SocketConnectingEvent value) connecting,
    required TResult Function(_SocketOnConnect value) onConnect,
    required TResult Function(_SocketConnectErrorEvent value) onConnectError,
    required TResult Function(_SocketConnectTimeoutEvent value)
        onConnectTimeout,
    required TResult Function(_SocketErrorEvent value) onError,
    required TResult Function(_SocketJoinedEvent value) onJoined,
    required TResult Function(_SocketDisconnect value) disconnect,
    required TResult Function(_SocketOnDisconnect value) onDisconnect,
    required TResult Function(_SocketSendMessage value) sendMessage,
    required TResult Function(_SocketReceiveMessage value) receiveMessage,
  }) {
    return onError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SocketConnect value)? connect,
    TResult? Function(_SocketConnectingEvent value)? connecting,
    TResult? Function(_SocketOnConnect value)? onConnect,
    TResult? Function(_SocketConnectErrorEvent value)? onConnectError,
    TResult? Function(_SocketConnectTimeoutEvent value)? onConnectTimeout,
    TResult? Function(_SocketErrorEvent value)? onError,
    TResult? Function(_SocketJoinedEvent value)? onJoined,
    TResult? Function(_SocketDisconnect value)? disconnect,
    TResult? Function(_SocketOnDisconnect value)? onDisconnect,
    TResult? Function(_SocketSendMessage value)? sendMessage,
    TResult? Function(_SocketReceiveMessage value)? receiveMessage,
  }) {
    return onError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SocketConnect value)? connect,
    TResult Function(_SocketConnectingEvent value)? connecting,
    TResult Function(_SocketOnConnect value)? onConnect,
    TResult Function(_SocketConnectErrorEvent value)? onConnectError,
    TResult Function(_SocketConnectTimeoutEvent value)? onConnectTimeout,
    TResult Function(_SocketErrorEvent value)? onError,
    TResult Function(_SocketJoinedEvent value)? onJoined,
    TResult Function(_SocketDisconnect value)? disconnect,
    TResult Function(_SocketOnDisconnect value)? onDisconnect,
    TResult Function(_SocketSendMessage value)? sendMessage,
    TResult Function(_SocketReceiveMessage value)? receiveMessage,
    required TResult orElse(),
  }) {
    if (onError != null) {
      return onError(this);
    }
    return orElse();
  }
}

abstract class _SocketErrorEvent implements SocketEvent {
  const factory _SocketErrorEvent() = _$_SocketErrorEvent;
}

/// @nodoc
abstract class _$$_SocketJoinedEventCopyWith<$Res> {
  factory _$$_SocketJoinedEventCopyWith(_$_SocketJoinedEvent value,
          $Res Function(_$_SocketJoinedEvent) then) =
      __$$_SocketJoinedEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_SocketJoinedEventCopyWithImpl<$Res>
    extends _$SocketEventCopyWithImpl<$Res, _$_SocketJoinedEvent>
    implements _$$_SocketJoinedEventCopyWith<$Res> {
  __$$_SocketJoinedEventCopyWithImpl(
      _$_SocketJoinedEvent _value, $Res Function(_$_SocketJoinedEvent) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_SocketJoinedEvent implements _SocketJoinedEvent {
  const _$_SocketJoinedEvent();

  @override
  String toString() {
    return 'SocketEvent.onJoined()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_SocketJoinedEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() connect,
    required TResult Function() connecting,
    required TResult Function() onConnect,
    required TResult Function() onConnectError,
    required TResult Function() onConnectTimeout,
    required TResult Function() onError,
    required TResult Function() onJoined,
    required TResult Function() disconnect,
    required TResult Function() onDisconnect,
    required TResult Function() sendMessage,
    required TResult Function(String message) receiveMessage,
  }) {
    return onJoined();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? connect,
    TResult? Function()? connecting,
    TResult? Function()? onConnect,
    TResult? Function()? onConnectError,
    TResult? Function()? onConnectTimeout,
    TResult? Function()? onError,
    TResult? Function()? onJoined,
    TResult? Function()? disconnect,
    TResult? Function()? onDisconnect,
    TResult? Function()? sendMessage,
    TResult? Function(String message)? receiveMessage,
  }) {
    return onJoined?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? connect,
    TResult Function()? connecting,
    TResult Function()? onConnect,
    TResult Function()? onConnectError,
    TResult Function()? onConnectTimeout,
    TResult Function()? onError,
    TResult Function()? onJoined,
    TResult Function()? disconnect,
    TResult Function()? onDisconnect,
    TResult Function()? sendMessage,
    TResult Function(String message)? receiveMessage,
    required TResult orElse(),
  }) {
    if (onJoined != null) {
      return onJoined();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SocketConnect value) connect,
    required TResult Function(_SocketConnectingEvent value) connecting,
    required TResult Function(_SocketOnConnect value) onConnect,
    required TResult Function(_SocketConnectErrorEvent value) onConnectError,
    required TResult Function(_SocketConnectTimeoutEvent value)
        onConnectTimeout,
    required TResult Function(_SocketErrorEvent value) onError,
    required TResult Function(_SocketJoinedEvent value) onJoined,
    required TResult Function(_SocketDisconnect value) disconnect,
    required TResult Function(_SocketOnDisconnect value) onDisconnect,
    required TResult Function(_SocketSendMessage value) sendMessage,
    required TResult Function(_SocketReceiveMessage value) receiveMessage,
  }) {
    return onJoined(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SocketConnect value)? connect,
    TResult? Function(_SocketConnectingEvent value)? connecting,
    TResult? Function(_SocketOnConnect value)? onConnect,
    TResult? Function(_SocketConnectErrorEvent value)? onConnectError,
    TResult? Function(_SocketConnectTimeoutEvent value)? onConnectTimeout,
    TResult? Function(_SocketErrorEvent value)? onError,
    TResult? Function(_SocketJoinedEvent value)? onJoined,
    TResult? Function(_SocketDisconnect value)? disconnect,
    TResult? Function(_SocketOnDisconnect value)? onDisconnect,
    TResult? Function(_SocketSendMessage value)? sendMessage,
    TResult? Function(_SocketReceiveMessage value)? receiveMessage,
  }) {
    return onJoined?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SocketConnect value)? connect,
    TResult Function(_SocketConnectingEvent value)? connecting,
    TResult Function(_SocketOnConnect value)? onConnect,
    TResult Function(_SocketConnectErrorEvent value)? onConnectError,
    TResult Function(_SocketConnectTimeoutEvent value)? onConnectTimeout,
    TResult Function(_SocketErrorEvent value)? onError,
    TResult Function(_SocketJoinedEvent value)? onJoined,
    TResult Function(_SocketDisconnect value)? disconnect,
    TResult Function(_SocketOnDisconnect value)? onDisconnect,
    TResult Function(_SocketSendMessage value)? sendMessage,
    TResult Function(_SocketReceiveMessage value)? receiveMessage,
    required TResult orElse(),
  }) {
    if (onJoined != null) {
      return onJoined(this);
    }
    return orElse();
  }
}

abstract class _SocketJoinedEvent implements SocketEvent {
  const factory _SocketJoinedEvent() = _$_SocketJoinedEvent;
}

/// @nodoc
abstract class _$$_SocketDisconnectCopyWith<$Res> {
  factory _$$_SocketDisconnectCopyWith(
          _$_SocketDisconnect value, $Res Function(_$_SocketDisconnect) then) =
      __$$_SocketDisconnectCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_SocketDisconnectCopyWithImpl<$Res>
    extends _$SocketEventCopyWithImpl<$Res, _$_SocketDisconnect>
    implements _$$_SocketDisconnectCopyWith<$Res> {
  __$$_SocketDisconnectCopyWithImpl(
      _$_SocketDisconnect _value, $Res Function(_$_SocketDisconnect) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_SocketDisconnect implements _SocketDisconnect {
  const _$_SocketDisconnect();

  @override
  String toString() {
    return 'SocketEvent.disconnect()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_SocketDisconnect);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() connect,
    required TResult Function() connecting,
    required TResult Function() onConnect,
    required TResult Function() onConnectError,
    required TResult Function() onConnectTimeout,
    required TResult Function() onError,
    required TResult Function() onJoined,
    required TResult Function() disconnect,
    required TResult Function() onDisconnect,
    required TResult Function() sendMessage,
    required TResult Function(String message) receiveMessage,
  }) {
    return disconnect();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? connect,
    TResult? Function()? connecting,
    TResult? Function()? onConnect,
    TResult? Function()? onConnectError,
    TResult? Function()? onConnectTimeout,
    TResult? Function()? onError,
    TResult? Function()? onJoined,
    TResult? Function()? disconnect,
    TResult? Function()? onDisconnect,
    TResult? Function()? sendMessage,
    TResult? Function(String message)? receiveMessage,
  }) {
    return disconnect?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? connect,
    TResult Function()? connecting,
    TResult Function()? onConnect,
    TResult Function()? onConnectError,
    TResult Function()? onConnectTimeout,
    TResult Function()? onError,
    TResult Function()? onJoined,
    TResult Function()? disconnect,
    TResult Function()? onDisconnect,
    TResult Function()? sendMessage,
    TResult Function(String message)? receiveMessage,
    required TResult orElse(),
  }) {
    if (disconnect != null) {
      return disconnect();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SocketConnect value) connect,
    required TResult Function(_SocketConnectingEvent value) connecting,
    required TResult Function(_SocketOnConnect value) onConnect,
    required TResult Function(_SocketConnectErrorEvent value) onConnectError,
    required TResult Function(_SocketConnectTimeoutEvent value)
        onConnectTimeout,
    required TResult Function(_SocketErrorEvent value) onError,
    required TResult Function(_SocketJoinedEvent value) onJoined,
    required TResult Function(_SocketDisconnect value) disconnect,
    required TResult Function(_SocketOnDisconnect value) onDisconnect,
    required TResult Function(_SocketSendMessage value) sendMessage,
    required TResult Function(_SocketReceiveMessage value) receiveMessage,
  }) {
    return disconnect(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SocketConnect value)? connect,
    TResult? Function(_SocketConnectingEvent value)? connecting,
    TResult? Function(_SocketOnConnect value)? onConnect,
    TResult? Function(_SocketConnectErrorEvent value)? onConnectError,
    TResult? Function(_SocketConnectTimeoutEvent value)? onConnectTimeout,
    TResult? Function(_SocketErrorEvent value)? onError,
    TResult? Function(_SocketJoinedEvent value)? onJoined,
    TResult? Function(_SocketDisconnect value)? disconnect,
    TResult? Function(_SocketOnDisconnect value)? onDisconnect,
    TResult? Function(_SocketSendMessage value)? sendMessage,
    TResult? Function(_SocketReceiveMessage value)? receiveMessage,
  }) {
    return disconnect?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SocketConnect value)? connect,
    TResult Function(_SocketConnectingEvent value)? connecting,
    TResult Function(_SocketOnConnect value)? onConnect,
    TResult Function(_SocketConnectErrorEvent value)? onConnectError,
    TResult Function(_SocketConnectTimeoutEvent value)? onConnectTimeout,
    TResult Function(_SocketErrorEvent value)? onError,
    TResult Function(_SocketJoinedEvent value)? onJoined,
    TResult Function(_SocketDisconnect value)? disconnect,
    TResult Function(_SocketOnDisconnect value)? onDisconnect,
    TResult Function(_SocketSendMessage value)? sendMessage,
    TResult Function(_SocketReceiveMessage value)? receiveMessage,
    required TResult orElse(),
  }) {
    if (disconnect != null) {
      return disconnect(this);
    }
    return orElse();
  }
}

abstract class _SocketDisconnect implements SocketEvent {
  const factory _SocketDisconnect() = _$_SocketDisconnect;
}

/// @nodoc
abstract class _$$_SocketOnDisconnectCopyWith<$Res> {
  factory _$$_SocketOnDisconnectCopyWith(_$_SocketOnDisconnect value,
          $Res Function(_$_SocketOnDisconnect) then) =
      __$$_SocketOnDisconnectCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_SocketOnDisconnectCopyWithImpl<$Res>
    extends _$SocketEventCopyWithImpl<$Res, _$_SocketOnDisconnect>
    implements _$$_SocketOnDisconnectCopyWith<$Res> {
  __$$_SocketOnDisconnectCopyWithImpl(
      _$_SocketOnDisconnect _value, $Res Function(_$_SocketOnDisconnect) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_SocketOnDisconnect implements _SocketOnDisconnect {
  const _$_SocketOnDisconnect();

  @override
  String toString() {
    return 'SocketEvent.onDisconnect()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_SocketOnDisconnect);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() connect,
    required TResult Function() connecting,
    required TResult Function() onConnect,
    required TResult Function() onConnectError,
    required TResult Function() onConnectTimeout,
    required TResult Function() onError,
    required TResult Function() onJoined,
    required TResult Function() disconnect,
    required TResult Function() onDisconnect,
    required TResult Function() sendMessage,
    required TResult Function(String message) receiveMessage,
  }) {
    return onDisconnect();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? connect,
    TResult? Function()? connecting,
    TResult? Function()? onConnect,
    TResult? Function()? onConnectError,
    TResult? Function()? onConnectTimeout,
    TResult? Function()? onError,
    TResult? Function()? onJoined,
    TResult? Function()? disconnect,
    TResult? Function()? onDisconnect,
    TResult? Function()? sendMessage,
    TResult? Function(String message)? receiveMessage,
  }) {
    return onDisconnect?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? connect,
    TResult Function()? connecting,
    TResult Function()? onConnect,
    TResult Function()? onConnectError,
    TResult Function()? onConnectTimeout,
    TResult Function()? onError,
    TResult Function()? onJoined,
    TResult Function()? disconnect,
    TResult Function()? onDisconnect,
    TResult Function()? sendMessage,
    TResult Function(String message)? receiveMessage,
    required TResult orElse(),
  }) {
    if (onDisconnect != null) {
      return onDisconnect();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SocketConnect value) connect,
    required TResult Function(_SocketConnectingEvent value) connecting,
    required TResult Function(_SocketOnConnect value) onConnect,
    required TResult Function(_SocketConnectErrorEvent value) onConnectError,
    required TResult Function(_SocketConnectTimeoutEvent value)
        onConnectTimeout,
    required TResult Function(_SocketErrorEvent value) onError,
    required TResult Function(_SocketJoinedEvent value) onJoined,
    required TResult Function(_SocketDisconnect value) disconnect,
    required TResult Function(_SocketOnDisconnect value) onDisconnect,
    required TResult Function(_SocketSendMessage value) sendMessage,
    required TResult Function(_SocketReceiveMessage value) receiveMessage,
  }) {
    return onDisconnect(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SocketConnect value)? connect,
    TResult? Function(_SocketConnectingEvent value)? connecting,
    TResult? Function(_SocketOnConnect value)? onConnect,
    TResult? Function(_SocketConnectErrorEvent value)? onConnectError,
    TResult? Function(_SocketConnectTimeoutEvent value)? onConnectTimeout,
    TResult? Function(_SocketErrorEvent value)? onError,
    TResult? Function(_SocketJoinedEvent value)? onJoined,
    TResult? Function(_SocketDisconnect value)? disconnect,
    TResult? Function(_SocketOnDisconnect value)? onDisconnect,
    TResult? Function(_SocketSendMessage value)? sendMessage,
    TResult? Function(_SocketReceiveMessage value)? receiveMessage,
  }) {
    return onDisconnect?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SocketConnect value)? connect,
    TResult Function(_SocketConnectingEvent value)? connecting,
    TResult Function(_SocketOnConnect value)? onConnect,
    TResult Function(_SocketConnectErrorEvent value)? onConnectError,
    TResult Function(_SocketConnectTimeoutEvent value)? onConnectTimeout,
    TResult Function(_SocketErrorEvent value)? onError,
    TResult Function(_SocketJoinedEvent value)? onJoined,
    TResult Function(_SocketDisconnect value)? disconnect,
    TResult Function(_SocketOnDisconnect value)? onDisconnect,
    TResult Function(_SocketSendMessage value)? sendMessage,
    TResult Function(_SocketReceiveMessage value)? receiveMessage,
    required TResult orElse(),
  }) {
    if (onDisconnect != null) {
      return onDisconnect(this);
    }
    return orElse();
  }
}

abstract class _SocketOnDisconnect implements SocketEvent {
  const factory _SocketOnDisconnect() = _$_SocketOnDisconnect;
}

/// @nodoc
abstract class _$$_SocketSendMessageCopyWith<$Res> {
  factory _$$_SocketSendMessageCopyWith(_$_SocketSendMessage value,
          $Res Function(_$_SocketSendMessage) then) =
      __$$_SocketSendMessageCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_SocketSendMessageCopyWithImpl<$Res>
    extends _$SocketEventCopyWithImpl<$Res, _$_SocketSendMessage>
    implements _$$_SocketSendMessageCopyWith<$Res> {
  __$$_SocketSendMessageCopyWithImpl(
      _$_SocketSendMessage _value, $Res Function(_$_SocketSendMessage) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_SocketSendMessage implements _SocketSendMessage {
  const _$_SocketSendMessage();

  @override
  String toString() {
    return 'SocketEvent.sendMessage()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_SocketSendMessage);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() connect,
    required TResult Function() connecting,
    required TResult Function() onConnect,
    required TResult Function() onConnectError,
    required TResult Function() onConnectTimeout,
    required TResult Function() onError,
    required TResult Function() onJoined,
    required TResult Function() disconnect,
    required TResult Function() onDisconnect,
    required TResult Function() sendMessage,
    required TResult Function(String message) receiveMessage,
  }) {
    return sendMessage();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? connect,
    TResult? Function()? connecting,
    TResult? Function()? onConnect,
    TResult? Function()? onConnectError,
    TResult? Function()? onConnectTimeout,
    TResult? Function()? onError,
    TResult? Function()? onJoined,
    TResult? Function()? disconnect,
    TResult? Function()? onDisconnect,
    TResult? Function()? sendMessage,
    TResult? Function(String message)? receiveMessage,
  }) {
    return sendMessage?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? connect,
    TResult Function()? connecting,
    TResult Function()? onConnect,
    TResult Function()? onConnectError,
    TResult Function()? onConnectTimeout,
    TResult Function()? onError,
    TResult Function()? onJoined,
    TResult Function()? disconnect,
    TResult Function()? onDisconnect,
    TResult Function()? sendMessage,
    TResult Function(String message)? receiveMessage,
    required TResult orElse(),
  }) {
    if (sendMessage != null) {
      return sendMessage();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SocketConnect value) connect,
    required TResult Function(_SocketConnectingEvent value) connecting,
    required TResult Function(_SocketOnConnect value) onConnect,
    required TResult Function(_SocketConnectErrorEvent value) onConnectError,
    required TResult Function(_SocketConnectTimeoutEvent value)
        onConnectTimeout,
    required TResult Function(_SocketErrorEvent value) onError,
    required TResult Function(_SocketJoinedEvent value) onJoined,
    required TResult Function(_SocketDisconnect value) disconnect,
    required TResult Function(_SocketOnDisconnect value) onDisconnect,
    required TResult Function(_SocketSendMessage value) sendMessage,
    required TResult Function(_SocketReceiveMessage value) receiveMessage,
  }) {
    return sendMessage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SocketConnect value)? connect,
    TResult? Function(_SocketConnectingEvent value)? connecting,
    TResult? Function(_SocketOnConnect value)? onConnect,
    TResult? Function(_SocketConnectErrorEvent value)? onConnectError,
    TResult? Function(_SocketConnectTimeoutEvent value)? onConnectTimeout,
    TResult? Function(_SocketErrorEvent value)? onError,
    TResult? Function(_SocketJoinedEvent value)? onJoined,
    TResult? Function(_SocketDisconnect value)? disconnect,
    TResult? Function(_SocketOnDisconnect value)? onDisconnect,
    TResult? Function(_SocketSendMessage value)? sendMessage,
    TResult? Function(_SocketReceiveMessage value)? receiveMessage,
  }) {
    return sendMessage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SocketConnect value)? connect,
    TResult Function(_SocketConnectingEvent value)? connecting,
    TResult Function(_SocketOnConnect value)? onConnect,
    TResult Function(_SocketConnectErrorEvent value)? onConnectError,
    TResult Function(_SocketConnectTimeoutEvent value)? onConnectTimeout,
    TResult Function(_SocketErrorEvent value)? onError,
    TResult Function(_SocketJoinedEvent value)? onJoined,
    TResult Function(_SocketDisconnect value)? disconnect,
    TResult Function(_SocketOnDisconnect value)? onDisconnect,
    TResult Function(_SocketSendMessage value)? sendMessage,
    TResult Function(_SocketReceiveMessage value)? receiveMessage,
    required TResult orElse(),
  }) {
    if (sendMessage != null) {
      return sendMessage(this);
    }
    return orElse();
  }
}

abstract class _SocketSendMessage implements SocketEvent {
  const factory _SocketSendMessage() = _$_SocketSendMessage;
}

/// @nodoc
abstract class _$$_SocketReceiveMessageCopyWith<$Res> {
  factory _$$_SocketReceiveMessageCopyWith(_$_SocketReceiveMessage value,
          $Res Function(_$_SocketReceiveMessage) then) =
      __$$_SocketReceiveMessageCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$_SocketReceiveMessageCopyWithImpl<$Res>
    extends _$SocketEventCopyWithImpl<$Res, _$_SocketReceiveMessage>
    implements _$$_SocketReceiveMessageCopyWith<$Res> {
  __$$_SocketReceiveMessageCopyWithImpl(_$_SocketReceiveMessage _value,
      $Res Function(_$_SocketReceiveMessage) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$_SocketReceiveMessage(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_SocketReceiveMessage implements _SocketReceiveMessage {
  const _$_SocketReceiveMessage(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'SocketEvent.receiveMessage(message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SocketReceiveMessage &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SocketReceiveMessageCopyWith<_$_SocketReceiveMessage> get copyWith =>
      __$$_SocketReceiveMessageCopyWithImpl<_$_SocketReceiveMessage>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() connect,
    required TResult Function() connecting,
    required TResult Function() onConnect,
    required TResult Function() onConnectError,
    required TResult Function() onConnectTimeout,
    required TResult Function() onError,
    required TResult Function() onJoined,
    required TResult Function() disconnect,
    required TResult Function() onDisconnect,
    required TResult Function() sendMessage,
    required TResult Function(String message) receiveMessage,
  }) {
    return receiveMessage(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? connect,
    TResult? Function()? connecting,
    TResult? Function()? onConnect,
    TResult? Function()? onConnectError,
    TResult? Function()? onConnectTimeout,
    TResult? Function()? onError,
    TResult? Function()? onJoined,
    TResult? Function()? disconnect,
    TResult? Function()? onDisconnect,
    TResult? Function()? sendMessage,
    TResult? Function(String message)? receiveMessage,
  }) {
    return receiveMessage?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? connect,
    TResult Function()? connecting,
    TResult Function()? onConnect,
    TResult Function()? onConnectError,
    TResult Function()? onConnectTimeout,
    TResult Function()? onError,
    TResult Function()? onJoined,
    TResult Function()? disconnect,
    TResult Function()? onDisconnect,
    TResult Function()? sendMessage,
    TResult Function(String message)? receiveMessage,
    required TResult orElse(),
  }) {
    if (receiveMessage != null) {
      return receiveMessage(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SocketConnect value) connect,
    required TResult Function(_SocketConnectingEvent value) connecting,
    required TResult Function(_SocketOnConnect value) onConnect,
    required TResult Function(_SocketConnectErrorEvent value) onConnectError,
    required TResult Function(_SocketConnectTimeoutEvent value)
        onConnectTimeout,
    required TResult Function(_SocketErrorEvent value) onError,
    required TResult Function(_SocketJoinedEvent value) onJoined,
    required TResult Function(_SocketDisconnect value) disconnect,
    required TResult Function(_SocketOnDisconnect value) onDisconnect,
    required TResult Function(_SocketSendMessage value) sendMessage,
    required TResult Function(_SocketReceiveMessage value) receiveMessage,
  }) {
    return receiveMessage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SocketConnect value)? connect,
    TResult? Function(_SocketConnectingEvent value)? connecting,
    TResult? Function(_SocketOnConnect value)? onConnect,
    TResult? Function(_SocketConnectErrorEvent value)? onConnectError,
    TResult? Function(_SocketConnectTimeoutEvent value)? onConnectTimeout,
    TResult? Function(_SocketErrorEvent value)? onError,
    TResult? Function(_SocketJoinedEvent value)? onJoined,
    TResult? Function(_SocketDisconnect value)? disconnect,
    TResult? Function(_SocketOnDisconnect value)? onDisconnect,
    TResult? Function(_SocketSendMessage value)? sendMessage,
    TResult? Function(_SocketReceiveMessage value)? receiveMessage,
  }) {
    return receiveMessage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SocketConnect value)? connect,
    TResult Function(_SocketConnectingEvent value)? connecting,
    TResult Function(_SocketOnConnect value)? onConnect,
    TResult Function(_SocketConnectErrorEvent value)? onConnectError,
    TResult Function(_SocketConnectTimeoutEvent value)? onConnectTimeout,
    TResult Function(_SocketErrorEvent value)? onError,
    TResult Function(_SocketJoinedEvent value)? onJoined,
    TResult Function(_SocketDisconnect value)? disconnect,
    TResult Function(_SocketOnDisconnect value)? onDisconnect,
    TResult Function(_SocketSendMessage value)? sendMessage,
    TResult Function(_SocketReceiveMessage value)? receiveMessage,
    required TResult orElse(),
  }) {
    if (receiveMessage != null) {
      return receiveMessage(this);
    }
    return orElse();
  }
}

abstract class _SocketReceiveMessage implements SocketEvent {
  const factory _SocketReceiveMessage(final String message) =
      _$_SocketReceiveMessage;

  String get message;
  @JsonKey(ignore: true)
  _$$_SocketReceiveMessageCopyWith<_$_SocketReceiveMessage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SocketState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(String status) connected,
    required TResult Function() disconnected,
    required TResult Function(String message) data,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(String status)? connected,
    TResult? Function()? disconnected,
    TResult? Function(String message)? data,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(String status)? connected,
    TResult Function()? disconnected,
    TResult Function(String message)? data,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SocketInitial value) initial,
    required TResult Function(_SocketConnected value) connected,
    required TResult Function(_SocketDisonnected value) disconnected,
    required TResult Function(_SocketData value) data,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SocketInitial value)? initial,
    TResult? Function(_SocketConnected value)? connected,
    TResult? Function(_SocketDisonnected value)? disconnected,
    TResult? Function(_SocketData value)? data,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SocketInitial value)? initial,
    TResult Function(_SocketConnected value)? connected,
    TResult Function(_SocketDisonnected value)? disconnected,
    TResult Function(_SocketData value)? data,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SocketStateCopyWith<$Res> {
  factory $SocketStateCopyWith(
          SocketState value, $Res Function(SocketState) then) =
      _$SocketStateCopyWithImpl<$Res, SocketState>;
}

/// @nodoc
class _$SocketStateCopyWithImpl<$Res, $Val extends SocketState>
    implements $SocketStateCopyWith<$Res> {
  _$SocketStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_SocketInitialCopyWith<$Res> {
  factory _$$_SocketInitialCopyWith(
          _$_SocketInitial value, $Res Function(_$_SocketInitial) then) =
      __$$_SocketInitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_SocketInitialCopyWithImpl<$Res>
    extends _$SocketStateCopyWithImpl<$Res, _$_SocketInitial>
    implements _$$_SocketInitialCopyWith<$Res> {
  __$$_SocketInitialCopyWithImpl(
      _$_SocketInitial _value, $Res Function(_$_SocketInitial) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_SocketInitial implements _SocketInitial {
  const _$_SocketInitial();

  @override
  String toString() {
    return 'SocketState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_SocketInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(String status) connected,
    required TResult Function() disconnected,
    required TResult Function(String message) data,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(String status)? connected,
    TResult? Function()? disconnected,
    TResult? Function(String message)? data,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(String status)? connected,
    TResult Function()? disconnected,
    TResult Function(String message)? data,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SocketInitial value) initial,
    required TResult Function(_SocketConnected value) connected,
    required TResult Function(_SocketDisonnected value) disconnected,
    required TResult Function(_SocketData value) data,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SocketInitial value)? initial,
    TResult? Function(_SocketConnected value)? connected,
    TResult? Function(_SocketDisonnected value)? disconnected,
    TResult? Function(_SocketData value)? data,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SocketInitial value)? initial,
    TResult Function(_SocketConnected value)? connected,
    TResult Function(_SocketDisonnected value)? disconnected,
    TResult Function(_SocketData value)? data,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _SocketInitial implements SocketState {
  const factory _SocketInitial() = _$_SocketInitial;
}

/// @nodoc
abstract class _$$_SocketConnectedCopyWith<$Res> {
  factory _$$_SocketConnectedCopyWith(
          _$_SocketConnected value, $Res Function(_$_SocketConnected) then) =
      __$$_SocketConnectedCopyWithImpl<$Res>;
  @useResult
  $Res call({String status});
}

/// @nodoc
class __$$_SocketConnectedCopyWithImpl<$Res>
    extends _$SocketStateCopyWithImpl<$Res, _$_SocketConnected>
    implements _$$_SocketConnectedCopyWith<$Res> {
  __$$_SocketConnectedCopyWithImpl(
      _$_SocketConnected _value, $Res Function(_$_SocketConnected) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? status = null,
  }) {
    return _then(_$_SocketConnected(
      null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_SocketConnected implements _SocketConnected {
  const _$_SocketConnected(this.status);

  @override
  final String status;

  @override
  String toString() {
    return 'SocketState.connected(status: $status)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SocketConnected &&
            (identical(other.status, status) || other.status == status));
  }

  @override
  int get hashCode => Object.hash(runtimeType, status);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SocketConnectedCopyWith<_$_SocketConnected> get copyWith =>
      __$$_SocketConnectedCopyWithImpl<_$_SocketConnected>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(String status) connected,
    required TResult Function() disconnected,
    required TResult Function(String message) data,
  }) {
    return connected(status);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(String status)? connected,
    TResult? Function()? disconnected,
    TResult? Function(String message)? data,
  }) {
    return connected?.call(status);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(String status)? connected,
    TResult Function()? disconnected,
    TResult Function(String message)? data,
    required TResult orElse(),
  }) {
    if (connected != null) {
      return connected(status);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SocketInitial value) initial,
    required TResult Function(_SocketConnected value) connected,
    required TResult Function(_SocketDisonnected value) disconnected,
    required TResult Function(_SocketData value) data,
  }) {
    return connected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SocketInitial value)? initial,
    TResult? Function(_SocketConnected value)? connected,
    TResult? Function(_SocketDisonnected value)? disconnected,
    TResult? Function(_SocketData value)? data,
  }) {
    return connected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SocketInitial value)? initial,
    TResult Function(_SocketConnected value)? connected,
    TResult Function(_SocketDisonnected value)? disconnected,
    TResult Function(_SocketData value)? data,
    required TResult orElse(),
  }) {
    if (connected != null) {
      return connected(this);
    }
    return orElse();
  }
}

abstract class _SocketConnected implements SocketState {
  const factory _SocketConnected(final String status) = _$_SocketConnected;

  String get status;
  @JsonKey(ignore: true)
  _$$_SocketConnectedCopyWith<_$_SocketConnected> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_SocketDisonnectedCopyWith<$Res> {
  factory _$$_SocketDisonnectedCopyWith(_$_SocketDisonnected value,
          $Res Function(_$_SocketDisonnected) then) =
      __$$_SocketDisonnectedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_SocketDisonnectedCopyWithImpl<$Res>
    extends _$SocketStateCopyWithImpl<$Res, _$_SocketDisonnected>
    implements _$$_SocketDisonnectedCopyWith<$Res> {
  __$$_SocketDisonnectedCopyWithImpl(
      _$_SocketDisonnected _value, $Res Function(_$_SocketDisonnected) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_SocketDisonnected implements _SocketDisonnected {
  const _$_SocketDisonnected();

  @override
  String toString() {
    return 'SocketState.disconnected()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_SocketDisonnected);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(String status) connected,
    required TResult Function() disconnected,
    required TResult Function(String message) data,
  }) {
    return disconnected();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(String status)? connected,
    TResult? Function()? disconnected,
    TResult? Function(String message)? data,
  }) {
    return disconnected?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(String status)? connected,
    TResult Function()? disconnected,
    TResult Function(String message)? data,
    required TResult orElse(),
  }) {
    if (disconnected != null) {
      return disconnected();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SocketInitial value) initial,
    required TResult Function(_SocketConnected value) connected,
    required TResult Function(_SocketDisonnected value) disconnected,
    required TResult Function(_SocketData value) data,
  }) {
    return disconnected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SocketInitial value)? initial,
    TResult? Function(_SocketConnected value)? connected,
    TResult? Function(_SocketDisonnected value)? disconnected,
    TResult? Function(_SocketData value)? data,
  }) {
    return disconnected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SocketInitial value)? initial,
    TResult Function(_SocketConnected value)? connected,
    TResult Function(_SocketDisonnected value)? disconnected,
    TResult Function(_SocketData value)? data,
    required TResult orElse(),
  }) {
    if (disconnected != null) {
      return disconnected(this);
    }
    return orElse();
  }
}

abstract class _SocketDisonnected implements SocketState {
  const factory _SocketDisonnected() = _$_SocketDisonnected;
}

/// @nodoc
abstract class _$$_SocketDataCopyWith<$Res> {
  factory _$$_SocketDataCopyWith(
          _$_SocketData value, $Res Function(_$_SocketData) then) =
      __$$_SocketDataCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$_SocketDataCopyWithImpl<$Res>
    extends _$SocketStateCopyWithImpl<$Res, _$_SocketData>
    implements _$$_SocketDataCopyWith<$Res> {
  __$$_SocketDataCopyWithImpl(
      _$_SocketData _value, $Res Function(_$_SocketData) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$_SocketData(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_SocketData implements _SocketData {
  const _$_SocketData(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'SocketState.data(message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SocketData &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SocketDataCopyWith<_$_SocketData> get copyWith =>
      __$$_SocketDataCopyWithImpl<_$_SocketData>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(String status) connected,
    required TResult Function() disconnected,
    required TResult Function(String message) data,
  }) {
    return data(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(String status)? connected,
    TResult? Function()? disconnected,
    TResult? Function(String message)? data,
  }) {
    return data?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(String status)? connected,
    TResult Function()? disconnected,
    TResult Function(String message)? data,
    required TResult orElse(),
  }) {
    if (data != null) {
      return data(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SocketInitial value) initial,
    required TResult Function(_SocketConnected value) connected,
    required TResult Function(_SocketDisonnected value) disconnected,
    required TResult Function(_SocketData value) data,
  }) {
    return data(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SocketInitial value)? initial,
    TResult? Function(_SocketConnected value)? connected,
    TResult? Function(_SocketDisonnected value)? disconnected,
    TResult? Function(_SocketData value)? data,
  }) {
    return data?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SocketInitial value)? initial,
    TResult Function(_SocketConnected value)? connected,
    TResult Function(_SocketDisonnected value)? disconnected,
    TResult Function(_SocketData value)? data,
    required TResult orElse(),
  }) {
    if (data != null) {
      return data(this);
    }
    return orElse();
  }
}

abstract class _SocketData implements SocketState {
  const factory _SocketData(final String message) = _$_SocketData;

  String get message;
  @JsonKey(ignore: true)
  _$$_SocketDataCopyWith<_$_SocketData> get copyWith =>
      throw _privateConstructorUsedError;
}
